## to get to previous cvxpy which we matched
## do a git checkout 757c6b38d in the cvxpy tree.
## then check master out again

0. It makes sense to split some R files into chunks so that it matches
the python code for ease of debugging in the future.  So we should
split up some files.

1. We combine `lin_ops.py` and `lin_utils.py` into a single file
`lin_ops.R`. We should rename all our functions `lo.is_scalar`,
`lo.is_const` to be `lu.is_scalar` and `lu.is_const` etc. respy. Also some
functions like `create_const`, `create_param` should be
`lu.create_const`, `lu.create_param` etc. Then global replace
everywhere. 

2. Following up on 1, in affine.R, SpecialIndex.graph_implementation
uses lu_reshape lu_create_const etc. These should be lu.reshape and
lu.create_const etc.

3. What is constr_map. How should the list elements be named? Zero or
Zeroconstraint.  See group_constraints in reductions.R

4. What is format_constr. Why is a method for a conic solver?

5. I have split utilitis and solver utilities.

6.  Also have moved solvers to qp_solver.R plus qp_solver_xxx.R. Same
for qp_solver



## ProblemData.cpp

Things to expose:
        problemData = cvxcore.build_matrix(lin_vec,
                                           int(var_length),
                                           id_to_col_C,
                                           param_to_size_C,
                                           s.get_num_threads())

            problemData.param_id = param_id
                problemData.vec_idx = i
                prob_len = problemData.getLen()
                tensor_V[param_id].append(problemData.getV(prob_len))
                tensor_I[param_id].append(problemData.getI(prob_len))
                tensor_J[param_id].append(problemData.getJ(prob_len))
