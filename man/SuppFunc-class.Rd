% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transforms.R
\docType{class}
\name{SuppFunc-class}
\alias{SuppFunc-class}
\alias{SuppFunc}
\title{The SuppFunc class}
\description{
Given a list of CVXR Constraint objects constraints involving a real CVXR
Variable x, consider the convex set
}
\details{
S = \\{ v : \\text{it's possible to satisfy all } \\texttt{constraints}
\\text{ when } \\texttt{x.value} = v \\}.

This object represents the \emph{support function} of :math:\code{S}.
This is the convex function

y \\mapsto \\max\\{ \\langle y, v \\rangle : v \\in S \\}.

The support function is a fundamental object in convex analysis.
It's extremely useful for expressing dual problems using Fenchel duality.
\subsection{Notes}{

You are allowed to use CVXR Variables other than x to define constraints,
but the set S only consists of objects (vectors or matrices) with the same
dimensions as x.

It's possible for the support function to take the value +Inf for a fixed
vector y. This is an important point, and it's one reason why support
functions are actually formally defined with the supremum sup rather than
the maximum max.
}
}
\section{Slots}{

\describe{
\item{\code{x}}{This \linkS4class{Variable} object cannot have any attributes, such as \code{PSD = TRUE}, \code{nonneg = TRUE}, \code{symmetric = TRUE}, etc...}

\item{\code{constraints}}{A list of \linkS4class{Constraint}s. Usually, these are constraints over x, and some number of auxiliary CVXR Variables. It is valid to supply \code{constraints = list()}.}
}}

\examples{
# If h = SuppFunc(x, constraints), then you can use h just like any other
# scalar-valued atom in CVXR. For example, if x was a CVXR Variable with
# ndim(x) == 1, you could do the following:

z <- Variable(10)
A <- matrix(rnorm(size(x)*10), nrow = size(x), ncol = 10)
c <- matrix(runif(10), nrow = 10, ncol = 1)
objective <- h(A \%*\% z) - t(c) \%*\% z
prob <- Problem(Minimize(objective), list())
result <- solve(prob)
}
