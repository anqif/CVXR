% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/024_dotsort.R
\docType{class}
\name{DotSort-class}
\alias{DotSort-class}
\alias{.DotSort}
\alias{DotSort}
\alias{validate_args,DotSort-method}
\alias{to_numeric,DotSort-method}
\alias{.grad,DotSort-method}
\alias{dim_from_args,DotSort-method}
\alias{sign_from_args,DotSort-method}
\alias{is_atom_convex,DotSort-method}
\alias{is_atom_concave,DotSort-method}
\alias{is_incr,DotSort-method}
\alias{is_decr,DotSort-method}
\alias{get_data,DotSort-method}
\title{The DotSort class.}
\usage{
DotSort(X, W)

\S4method{validate_args}{DotSort}(object)

\S4method{to_numeric}{DotSort}(object, values)

\S4method{.grad}{DotSort}(object, values)

\S4method{dim_from_args}{DotSort}(object)

\S4method{sign_from_args}{DotSort}(object)

\S4method{is_atom_convex}{DotSort}(object)

\S4method{is_atom_concave}{DotSort}(object)

\S4method{is_incr}{DotSort}(object, idx)

\S4method{is_decr}{DotSort}(object, idx)

\S4method{get_data}{DotSort}(object)
}
\arguments{
\item{X}{An \linkS4class{Expression}.}

\item{W}{A numeric matrix.}

\item{object}{A \linkS4class{DotSort} object.}

\item{values}{A list of numeric values for the arguments}

\item{idx}{An index into the atom.}
}
\description{
This class represents the value
}
\details{
\deqn{\langle sort\left(vec(X)\right), sort\left(vec(W)\right) \rangle},

where \eqn{X} is an expression and \eqn{W} is a constant.

Both arguments are flattened, i.e., we define \eqn{x = vec(X)} and \eqn{w = vec(W)}.
If the length of \eqn{w} is less than the length of \eqn{x}, it is conceptually padded with zeroes.
When the length of \eqn{w} is larger than the length of \eqn{x}, an exception is raised.

DotSort is a generalization of SumLargest and SumSmallest:
SumLargest(X, 3) is equivalent to DotSort(X, c(1,1,1))
SumLargest(X, 3.5) is equivalent to DotSort(X, c(1,1,1,0.5))
SumSmallest(X, 3) is equivalent to -DotSort(X, c(-1,-1,-1))

When the constant argument is not a boolean vector, DotSort can be considered as a weighted sum
of \eqn{x}, where the largest weight is assigned to the largest entry in \eqn{x}, etc.
}
\section{Methods (by generic)}{
\itemize{
\item \code{validate_args(DotSort)}: Check that the arguments are valid.

\item \code{to_numeric(DotSort)}: The inner product of the sorted values of vec(X) and the sorted (and potentially padded) values of vec(W).

\item \code{.grad(DotSort)}: Gives the (sub/super)gradient of the atom w.r.t. each variable

\item \code{dim_from_args(DotSort)}: The dimensions of the atom determined from its arguments.

\item \code{sign_from_args(DotSort)}: The (is positive, is negative) sign of the atom.

\item \code{is_atom_convex(DotSort)}: Is the atom convex?

\item \code{is_atom_concave(DotSort)}: Is the atom concave?

\item \code{is_incr(DotSort)}: Is the atom weakly increasing in the index?

\item \code{is_decr(DotSort)}: Is the atom weakly decreasing in the index?

\item \code{get_data(DotSort)}: Empty list because W is stored as an argument.

}}
