# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Create a new LinOp object.
#'
#' @return an external ptr (Rcpp::XPtr) to a LinOp object instance.
.LinOp__new <- function() {
    .Call('_CVXR_LinOp__new', PACKAGE = 'CVXR')
}

#' Get the \code{sparse} flag field for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return TRUE or FALSE
.LinOp__get_sparse <- function(xp) {
    .Call('_CVXR_LinOp__get_sparse', PACKAGE = 'CVXR', xp)
}

#' Set the flag \code{sparse} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param sparseSEXP an R boolean
.LinOp__set_sparse <- function(xp, sparseSEXP) {
    invisible(.Call('_CVXR_LinOp__set_sparse', PACKAGE = 'CVXR', xp, sparseSEXP))
}

#' Get the field named \code{sparse_data} from the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return a \link[Matrix]{dgCMatrix-class} object
.LinOp__get_sparse_data <- function(xp) {
    .Call('_CVXR_LinOp__get_sparse_data', PACKAGE = 'CVXR', xp)
}

#' Set the field named \code{sparse_data} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param sparseMat a \link[Matrix]{dgCMatrix-class} object
.LinOp__set_sparse_data <- function(xp, sparseMat) {
    invisible(.Call('_CVXR_LinOp__set_sparse_data', PACKAGE = 'CVXR', xp, sparseMat))
}

#' Get the field \code{dense_data} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return a MatrixXd object
.LinOp__get_dense_data <- function(xp) {
    .Call('_CVXR_LinOp__get_dense_data', PACKAGE = 'CVXR', xp)
}

#' Set the field \code{dense_data} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param denseMat a standard matrix object in R
.LinOp__set_dense_data <- function(xp, denseMat) {
    invisible(.Call('_CVXR_LinOp__set_dense_data', PACKAGE = 'CVXR', xp, denseMat))
}

#' Get the field \code{size} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return an integer vector
.LinOp__get_size <- function(xp) {
    .Call('_CVXR_LinOp__get_size', PACKAGE = 'CVXR', xp)
}

#' Set the field \code{size} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param value an integer vector object in R
.LinOp__set_size <- function(xp, value) {
    invisible(.Call('_CVXR_LinOp__set_size', PACKAGE = 'CVXR', xp, value))
}

#' Perform a push back operation on the \code{args} field of LinOp
#'
#' @param xp the LinOp Object XPtr
#' @param yp the LinOp Object XPtr to push
.LinOp__args_push_back <- function(xp, yp) {
    invisible(.Call('_CVXR_LinOp__args_push_back', PACKAGE = 'CVXR', xp, yp))
}

#' Perform a push back operation on the \code{size} field of LinOp
#'
#' @param xp the LinOp Object XPtr
#' @param intVal the integer value to push back
.LinOp__size_push_back <- function(xp, intVal) {
    invisible(.Call('_CVXR_LinOp__size_push_back', PACKAGE = 'CVXR', xp, intVal))
}

#' Set the field named \code{type} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param typeValue an integer value
.LinOp__set_type <- function(xp, typeValue) {
    invisible(.Call('_CVXR_LinOp__set_type', PACKAGE = 'CVXR', xp, typeValue))
}

#' Get the field named \code{type} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return an integer value for type
.LinOp__get_type <- function(xp) {
    .Call('_CVXR_LinOp__get_type', PACKAGE = 'CVXR', xp)
}

#' Perform a push back operation on the \code{slice} field of LinOp
#'
#' @param xp the LinOp Object XPtr
#' @param intVec an integer vector to push back
.LinOp__slice_push_back <- function(xp, intVec) {
    invisible(.Call('_CVXR_LinOp__slice_push_back', PACKAGE = 'CVXR', xp, intVec))
}

#' Get the slice field of the LinOp Object
#'
#' @param xp the LinOp Object XPtr
#' @return the value of the slice field of the LinOp Object
.LinOp__get_slice <- function(xp) {
    .Call('_CVXR_LinOp__get_slice', PACKAGE = 'CVXR', xp)
}

#' Set the slice field of the LinOp Object
#'
#' @param xp the LinOp Object XPtr
#' @param value a list of integer vectors, e.g. \code{list(1:10, 2L, 11:15)}
#' @return the value of the slice field of the LinOp Object
.LinOp__set_slice <- function(xp, value) {
    invisible(.Call('_CVXR_LinOp__set_slice', PACKAGE = 'CVXR', xp, value))
}

#' Get the id field of the LinOp Object
#'
#' @param xp the LinOp Object XPtr
#' @return the value of the id field of the LinOp Object
.LinOp__get_id <- function(xp) {
    .Call('_CVXR_LinOp__get_id', PACKAGE = 'CVXR', xp)
}

#' Create a new LinOpVector object.
#'
#' @return an external ptr (Rcpp::XPtr) to a LinOp object instance.
.LinOpVector__new <- function() {
    .Call('_CVXR_LinOpVector__new', PACKAGE = 'CVXR')
}

#' Perform a push back operation on the \code{args} field of LinOp
#'
#' @param xp the LinOpVector Object XPtr
#' @param yp the LinOp Object XPtr to push
.LinOpVector__push_back <- function(xp, yp) {
    invisible(.Call('_CVXR_LinOpVector__push_back', PACKAGE = 'CVXR', xp, yp))
}

#' Return the LinOp element at index i (0-based)
#'
#' @param lvec the LinOpVector Object XPtr
#' @param i the index
.LinOp_at_index <- function(lvec, i) {
    .Call('_CVXR_LinOp_at_index', PACKAGE = 'CVXR', lvec, i)
}

#' Create a new ConstLinOpVector object.
#'
#' @return an external ptr (Rcpp::XPtr) to a LinOp object instance.
.ConstLinOpVector__new <- function() {
    .Call('_CVXR_ConstLinOpVector__new', PACKAGE = 'CVXR')
}

#' Perform a push back operation on the \code{args} field of LinOp
#'
#' @param xp the ConstLinOpVector Object XPtr
#' @param yp the LinOp Object XPtr to push
.ConstLinOpVector__push_back <- function(xp, yp) {
    invisible(.Call('_CVXR_ConstLinOpVector__push_back', PACKAGE = 'CVXR', xp, yp))
}

#' Return the LinOp element at index i (0-based)
#'
#' @param lvec the ConstLinOpVector Object XPtr
#' @param i the index
.ConstLinOp_at_index <- function(lvec, i) {
    .Call('_CVXR_ConstLinOp_at_index', PACKAGE = 'CVXR', lvec, i)
}

#' Get the \code{sparse} flag field for the LinOp object
#'
#' @param xp the LinOpVector Object XPtr
#' @param v the \code{id_to_col} named int vector in R with integer names
#' @return a XPtr to ProblemData Object
.build_matrix_0 <- function(xp, v) {
    .Call('_CVXR_build_matrix_0', PACKAGE = 'CVXR', xp, v)
}

#' Get the \code{sparse} flag field for the LinOp object
#'
#' @param xp the LinOpVector Object XPtr
#' @param v1 the \code{id_to_col} named int vector in R with integer names
#' @param v2 the \code{constr_offsets} vector of offsets (an int vector in R)
#' @return a XPtr to ProblemData Object
.build_matrix_1 <- function(xp, v1, v2) {
    .Call('_CVXR_build_matrix_1', PACKAGE = 'CVXR', xp, v1, v2)
}

.cpp_convolve <- function(xa, xb) {
    .Call('_CVXR_cpp_convolve', PACKAGE = 'CVXR', xa, xb)
}

.sweep_dgCmat_in_place <- function(A, c_part) {
    invisible(.Call('_CVXR_multiply_dgCMatrix_vector', PACKAGE = 'CVXR', A, c_part))
}

.sweep_in_place <- function(P, c_part) {
    invisible(.Call('_CVXR_sweep_in_place', PACKAGE = 'CVXR', P, c_part))
}

upper_tri_to_full <- function(n) {
    .Call('_CVXR_upper_tri_to_full', PACKAGE = 'CVXR', n)
}

#' Create a new ProblemData object.
#'
#' @return an external ptr (Rcpp::XPtr) to a ProblemData object instance.
.ProblemData__new <- function() {
    .Call('_CVXR_ProblemData__new', PACKAGE = 'CVXR')
}

#' Get the vec_idx field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return an integer vector of the field vec_idx from the ProblemData Object
.ProblemData__get_vec_idx <- function(xp) {
    .Call('_CVXR_ProblemData__get_vec_idx', PACKAGE = 'CVXR', xp)
}

#' Set the vec_idx field in the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param idx an int value for field vec_idx of the ProblemData object
.ProblemData__set_vec_idx <- function(xp, idx) {
    invisible(.Call('_CVXR_ProblemData__set_vec_idx', PACKAGE = 'CVXR', xp, idx))
}

#' Get the param_id field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return an integer vector of the field param_id from the ProblemData Object
.ProblemData__get_param_id <- function(xp) {
    .Call('_CVXR_ProblemData__get_param_id', PACKAGE = 'CVXR', xp)
}

#' Set the param_id field in the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param idx an int value for field param_id of the ProblemData object
.ProblemData__set_param_id <- function(xp, idx) {
    invisible(.Call('_CVXR_ProblemData__set_param_id', PACKAGE = 'CVXR', xp, idx))
}

#' Get the length of V, I, J
#'
#' @param xp the ProblemData Object XPtr
#' @return the length of V, I, J 
.ProblemData__getLen <- function(xp) {
    .Call('_CVXR_ProblemData__getLen', PACKAGE = 'CVXR', xp)
}

#' Get the V field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param num_values the number of values to return
#' @return a numeric vector of doubles (the field V) from the ProblemData Object
.ProblemData__get_V <- function(xp, num_values) {
    .Call('_CVXR_ProblemData__get_V', PACKAGE = 'CVXR', xp, num_values)
}

#' Get the I field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param num_values the number of values to return
#' @return an integer vector of the field I from the ProblemData Object
.ProblemData__get_I <- function(xp, num_values) {
    .Call('_CVXR_ProblemData__get_I', PACKAGE = 'CVXR', xp, num_values)
}

#' Get the J field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param num_values the number of values to return
#' @return an integer vector of the field J from the ProblemData Object
.ProblemData__get_J <- function(xp, num_values) {
    .Call('_CVXR_ProblemData__get_J', PACKAGE = 'CVXR', xp, num_values)
}

#'  Build a sparse matrix representation of the cone program, given a list of linear operations
#' @param xp the ConstLinOpVector object XPtr
#' @param var_length the variable length
#' @param idc the \code{id_to_col} named int vector in R with integer names
#' @param psize the \code{param_to_size} named int vector in R with integer names
#' @param num_threads the int number of threads
#' @return a XPtr to a ProblemData Object
.build_matrix_0 <- function(xp, var_length, idc, psize, num_threads) {
    .Call('_CVXR_build_matrix_0', PACKAGE = 'CVXR', xp, var_length, idc, psize, num_threads)
}

