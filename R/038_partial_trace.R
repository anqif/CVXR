#####
## DO NOT EDIT THIS FILE!! EDIT THE SOURCE INSTEAD: rsrc_tree/atoms/affine/partial_trace.R
#####

## CVXPY SOURCE: cvxpy/atoms/affine/partial_trace.py

#'
#' The PartialTrace atom.
#' 
#' Assume \eqn{expr = X_1 \otimes \cdots \otimes X_n} is a 2D Kronecker product 
#' composed of \eqn{n = length(dims)} implicit subsystems. 
#' Letting \eqn{k = axis}, this class represents the partial trace of \eqn{expr} 
#' along its \eqn{k}-th implicit subsystem:
#' 
#' \deqn{tr(X_k) (X_1 \otimes \cdots \otimes X_{k-1} \otimes X_{k+1} \otimes \cdots \otimes X_n)}
#'
#' @param expr An \linkS4class{Expression} representing a 2D expression of which to take the partial trace.
#' @param dims A vector of integers encoding the dimensions of each subsystem.
#' @param axis The index of the subsystem to be traced out from the tensor product that defines \code{expr}.
#' @return The partial trace of \code{expr}.
PartialTrace <- function(expr, dims, axis) {
  expr <- as.Constant(expr)
  dims <- as.integer(dims)
  axis <- as.integer(axis)
  
  if(any(dims) <= 0)
    stop("dims must have positive integer entries")
  if(axis <= 0)
    stop("axis must be a positive integer")
  if(ndim(expr) < 2 || dim(expr)[1] != dim(expr)[2])
    stop("Only supports square matrices")
  if(axis <= 0 || axis > length(dims))
    stop("Invalid axis argument, should be between 1 and ", length(dims))
  if(dim(expr)[1] != base::prod(dims))
    stop("Dimension of system doesn't correspond to dimension of subsystems")
  
  term_list <- lapply(seq_len(dims[axis]), function(j) { PartialTrace.term(expr, j, dims, axis) })
  return(AddExpression(arg_groups = term_list))
}

#
# Helper function for PartialTrace.
#
# Parameters
# -----------
# expr: The 2D expression of which to take the partial trace.
# j: The term in the partial trace sum.
# dims: A vector of integers encoding the dimensions of each subsystem.
# axis: The index of the subsystem to be traced out from the tensor product that defines expr.
#
# (I ⊗ <j| ⊗ I) x (I ⊗ |j> ⊗ I) for all j's
# in the system we want to trace out.
# This function returns the jth term in the sum, namely
# (I ⊗ <j| ⊗ I) x (I ⊗ |j> ⊗ I).
#
PartialTrace.term <- function(expr, j, dims, axis) {
  a <- Matrix(1, 1, 1, sparse = TRUE)
  b <- Matrix(1, 1, 1, sparse = TRUE)
  
  ndims <- length(dims)
  for(i_axis in seq_len(ndims)) {
    dim <- dims[i_axis]
    if(i_axis == axis) {
      v <- sparseMatrix(j, 1, x = 1, dims = c(dim, 1))
      a <- kronecker(a, t(v))
      b <- kronecker(b, v)
    } else {
      eye_mat <- sparseMatrix(seq_len(dim), seq_len(dim), x = 1)
      a <- kronecker(a, eye_mat)
      b <- kronecker(b, eye_mat)
    }
  }
  return(a %*% expr %*% b)
}

