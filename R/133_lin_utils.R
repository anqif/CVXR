#####
## DO NOT EDIT THIS FILE!! EDIT THE SOURCE INSTEAD: rsrc_tree/lin_ops/lin_utils.R
#####

## CVXPY SOURCE: cvxpy/lin_ops/lin_utils.py
## NEEDS: lin_op.R

## All items here begin with prefix "lu."

## get_id <- function() {
##   # sample.int(.Machine$integer.max, 1)
##     uuid::UUIDgenerate()
## }
.lu.COUNTER <- 0L

#'
#' Get ID
#'
#' Get the next identifier value.
#'
#' @return A new unique integer identifier.
#' @export
#' @examples
#' \dontrun{
#'    get_id()
#' }
lu.get_id <- function() {
  new_id <- .lu.COUNTER
  .lu.COUNTER <<- .lu.COUNTER + 1L
  new_id
}

#' Create a new internal variable
#' @param dim the rows, cols dimensions of the variable as a vector, in order
#' @param id the id of the variable, automatically generated if not specified
#' @return a LinOp representing the new variable
lu.create_var <- function(dim, var_id = lu.get_id()) {
  lo.LinOp(lo.VARIABLE, dim, list(), var_id)
}

#' Wrap a parameter
#' @param dim the rows, cols dimensions of the parameter as a vector in order
#' @param id the id of the parameter, automatically generated if not specified
#' @return a LinOp wrapping the parameter
lu.create_param <- function(dim, param_id = lu.get_id()) {
  lo.LinOp(lo.PARAM, dim, list(), param_id)
}

#' Wrap a constant
#' @param value a scalar, matrix or sparse matrix
#' @param dim the rows, cols dimensions of the constant as a vector, in order
#' @param sparse a flag indicating if object is sparse matrix or not
#' @return a LinOp wrapping the constant
lu.create_const <- function(value, dim, sparse = FALSE) {
  if(all(dim == c(1L, 1L)))
    op_type <- lo.SCALAR_CONST
  else if (sparse)
    op_type <- lo.SPARSE_CONST
  else
    op_type <- lo.DENSE_CONST
  lo.LinOp(op_type, dim, list(), value)
}

#' Is the LinOp a scalar?
#' @param operator the LinOp to test
#' @return `TRUE` if a scalar, else `FALSE`
lu.is_scalar <- function(operator) {
  length(operator$dim) == 0L || as.integer(prod(operator$dim)) == 1L
}

#' Is the LinOp a constant?
#' @param operator the LinOp to test
#' @return `TRUE` if a constant, else `FALSE`
lu.is_const <- function(operator) {
  operator$type %in% c(lo.SCALAR_CONST, lo.SPARSE_CONST, lo.DENSE_CONST)
}


#' Add linear operators
#' @param a list of linear operators to sum
#' @return a LinOp representing the sum of the operators
lu.sum_expr <- function(operators) {
  lo.LinOp(lo.SUM, operators[[1L]]$dim, operators)
}

#' Negate an operator
#' @param operator the LinOp to negate
#' @return the negated operator
lu.neg_expr <- function(operator) {
  lo.LinOp(lo.NEG, operator$dim, list(operator))
}

#' Subtract two operators
#' @param lh_op the LinOp on LHS
#' @param rh_op the LinOp on RHS
#' @return the resulting subtracted operator
lu.sub_expr <- function(lh_op, rh_op) {
  lu.sum_expr(list(lh_op, lu.neg_expr(rh_op)))
}

#' Promote arguments for multiplication
#' @param lh_op LinOp
#'   The left-hand operator in the multiplication
#' @param rh_op LinOp
#'   The right-hand operator in the multiplication
#' @return A list containing the following elements:
#'   \item{lh_op}{Promoted left-hand operator}
#'   \item{rh_op}{Promoted right-hand operator}
#'   \item{dim}{Shape of the product}
lu.promote_lin_ops_for_mul <- function(lh_op, rh_op) {
  promoted_dims <- u.shape.mul_dims_promote(lh_op$dim, rh_op$dim)
  list(
    lo.LinOp(lh_op$type, promoted_dims[[1L]], lh_op$args, lh_op$data),
    lo.LinOp(rh_op$type, promoted_dims[[2L]], rh_op$args, rh_op$data),
    promoted_dims[[3L]]
  )
}

#' Multiply two linear operators, with the constant on the left
#' @param lh_op the left-hand operator in the product
#' @param rh_op the right-hand operator in the product
#' @param dim the shape of the product
#' @return a linear operator representing the product
lu.mul_expr <- function(lh_op, rh_op, dim) {
  lo.LinOp(lo.MUL_EXPR, dim, list(rh_op), lh_op)
}

#' Multiply two linear operators, with the constant on the right
#' @param lh_op the left-hand operator in the product
#' @param rh_op the right-hand operator in the product
#' @return a linear operator representing the product
lu.rmul_expr <- function(lh_op, rh_op, dim) {
  lo.LinOp(lo.RMUL_EXPR, dim, list(lh_op), rh_op)
}

#' Multiply two linear operators, elementwise
#' @param lh_op the left-hand operator in the product
#' @param rh_op the right-hand operator in the product
#' @return a linear operator representing the product
lu.multiply <- function(lh_op, rh_op) {
  lo.LinOp(lo.MUL_ELEM, lh_op$dim, list(rh_op), lh_op)
}

#' Compute the Kronecker product of two matrices, where the right operand is a variable
#' @param lh_op the left-hand operator in the product
#' @param rh_op the right-hand operator in the product
#' @param dim the dimension of the product
#' @return a linear operator representing the Kronecker product
lu.kron_r <- function(lh_op, rh_op, dim) {
  lo.LinOp(lo.KRON_R, dim, list(rh_op), lh_op)
}

#' Compute the Kronecker product of two matrices, where the left operand is a variable
#' @param lh_op the left-hand operator in the product
#' @param rh_op the right-hand operator in the product
#' @param dim the dimension of the product
#' @return a linear operator representing the Kronecker product
lu.kron_l <- function(lh_op, rh_op, dim) {
  lo.LinOp(lo.KRON_L, dim, list(rh_op), lh_op)
}

#' Divide one linear operator by another where the right operand is a scalar constant
#' @param lh_op the left-hand operator in the quotient
#' @param rh_op the right-hand operator in the quotient
#' @return a linear operator representing the quotient
lu.div_expr <- function(lh_op, rh_op) {
  lo.LinOp(lo.DIV, lh_op$dim, list(lh_op), rh_op)
}

#' Promote a scalar operator to the specified dimensions
#' @param operator the operator to promote
#' @param dim the dimensions to promote to
#' @return a linear operator representing the promotion
lu.promote <- function(operator, dim) {
  lo.LinOp(lo.PROMOTE, dim, list(operator))
}

#' Sum the entries of the given operator.
#' @param operator the operator to sum the entries of
#' @param dim the dimensions of the sum
#' @return an operator representing the sum
lu.sum_entries <- function(operator, dim) {
  lo.LinOp(lo.SUM_ENTRIES, dim, list(operator))
}

#' Sum the diagonal entries of an operator
#' @param expr the operator to sum the diagonal entries of
#' @return an operator representing the sum of the diagonal entries
lu.trace <- function(operator) {
  lo.LinOp(lo.TRACE, c(1L, 1L), list(operator))
}

#' Index/slice an operator
#' @param operator the expression to index
#' @param dim the dimensions of the expression after indexing
#' @param keys a list of row slice, column slice
#' @return an operator representing the indexing
lu.index <- function(operator, dim, keys) {
  lo.LinOp(lo.INDEX, dim, list(operator), keys)
}

#' Create 1D discrete convolution of two vectors
#' @param lh_op the left-hand operator in the convolution
#' @param rh_op the right-hand operator in the convolution
#' @param dim the dimension of the convolution
#' @return a linear operator representing the convolution
lu.conv <- function(lh_op, rh_op, dim) {
  lo.LinOp(lo.CONV, dim, list(rh_op), lh_op)
}

#' Transpose an operator
#' @param operator the operator to sum the entries of
#' @return an operator representing the transpose
lu.transpose <- function(operator) {
  if(length(operator$dim) < 2L)
    operator
  else if(length(operator$dim) > 2L)
    stop("Unimplemented")
  else {
    new_dim <- c(operator$dim[2L], operator$dim[1L])
    lo.LinOp(lo.TRANSPOSE, new_dim, list(operator))
  }
}

#' Reshape an operator
#' @param operator the operator to reshape
#' @param dim the dimensions of the reshaped operator
#' @return an operator representing the reshaping
lu.reshape <- function(operator, dim) {
  lo.LinOp(lo.RESHAPE_EXPR, dim, list(operator))
}

#' Convert a vector to a diagonal matrix
#' @param operator he operator to convert to a diagonal matrix
#' @return LinOp representing the diagonal matrix
lu.diag_vec <- function(operator) {
  new_dim <- c(operator$dim[1L], operator$dim[1L])
  lo.LinOp(lo.DIAG_VEC, new_dim, list(operator))
}

#' Convert the diagonal of a matrix to a vector
#' @param operator the operator to convert to a vector
#' @return LinOp representing the matrix diagonal
lu.diag_mat <- function(operator) {
  new_dim <- c(operator$dim[1], 1)
  lo.LinOp(lo.DIAG_MAT, new_dim, list(operator))
}

#' Create vectorized upper triangular portion of a square matrix
#' @param operator the matrix operator
#' @return LinOp representing the vectorized upper triangle
lu.upper_tri <- function(operator) {
  entries <- operator$dim[1L] * operator$dim[2L]
  new_dim <- c(floor((entries - operator$dim[1L])/2), 1L)
  lo.LinOp(lo.UPPER_TRI, new_dim, list(operator))
}

#' Concatenate operators horizontally
#' @param operators the operators to concatenate
#' @param dim the dimensions of the result
#' @return LinOp representing the horizontally stacked operators
lu.hstack <- function(operators, dim) {
  lo.LinOp(lo.HSTACK, dim, operators)
}

#' Concatenate operators vertically
#' @param operators the operators to concatenate
#' @param dim the dimensions of the result
#' @return LinOp representing the vertically stacked operators
lu.vstack <- function(operators, dim) {
  lo.LinOp(lo.VSTACK, dim, operators)
}

#' Return a constraint as a LinOp
#' @param lh_op the left-hand operator in the constraint
#' @param rh_op the right-hand operator in the constraint
#' @return the LinOp representing the constraint
lu.get_constr_expr <- function(lh_op, rh_op) {
  if(missing(rh_op))
    lh_op
  else
    lu.sum_expr(list(lh_op, lu.neg_expr(rh_op)))
}

#' Create an internal equality constraint as a LinOp
#' @param lh_op the left-hand operator in the constraint
#' @param rh_op the right-hand operator in the constraint
#' @param constr_id a id for the constraint, automatically generated if not specified
#' @return the LinOp representing the equality constraint
lu.create_eq <- function(lh_op, rh_op, constr_id = lu.get_id()) {
  expr <- get_constr_expr(lh_op, rh_op)
  LinEqConstr(expr, constr_id, lh_op$dim)
}

#' Create an internal less than or equal to constraint as a LinOp
#' @param lh_op the left-hand operator in the constraint
#' @param rh_op the right-hand operator in the constraint
#' @param constr_id a id for the constraint, automatically generated if not specified
#' @return the LinOp representing the less than or equal to constraint
lu.create_leq <- function(lh_op, rh_op, constr_id = lu.get_id()) {
  expr <- get_constr_expr(lh_op, rh_op)
  LinLeqConstr(expr, constr_id, lh_op$dim)
}

#' Create an internal greater than or equal to constraint as a LinOp
#' @param lh_op the left-hand operator in the constraint
#' @param rh_op the right-hand operator in the constraint
#' @param constr_id a id for the constraint, automatically generated if not specified
#' @return the LinOp representing the greater than or equal to constraint
lu.create_geq <- function(lh_op, rh_op, constr_id = lu.get_id()) {
  if (!missing(rh_op))
    rh_op <- lu.neg_expr(rh_op)
  create_leq(lu.neg_expr(lh_op), rh_op, constr_id)
}

#' Get a list of variables in the operator and their dimensions
#' @param operator the operator whose variables and dimensions are needed
#' @return a list of var_id, var dim pairs
lu.get_expr_vars <- function(operator) {
  ## TODO: This is recursive and should be improved
  if(operator$type == lo.VARIABLE)
    list(list(operator$data, operator$dim))
  else {
    vars_ <- list()
    for(arg in operator$args)
      vars_ <- c(vars_, get_expr_vars(arg))
    vars_
    ## Maybe lapply(operator$args, lu.get_expr_vars) ??
  }
}

#' Get a list of parameters in the operator
#' @param operator the operator whose parameters are needed
#' @return a list of parameters in the operator
lu.get_expr_params <- function(operator) {
  if(operator$type == lo.PARAM)
    parameters(operator$data)
  else {
    params <- list()
    for(arg in operator$args)
      params <- c(params, get_expr_params(arg))
    if(inherits(operator$data, "LinOp"))
      params <- c(params, get_expr_params(operator$data))
    params
  }
}

#' Creates a copy of the constraint modified according to func
#' @param constr the `LinConstraint` constraint to modify
#' @param func a function to modify the constraint expression
#' @return a copy of the constraint with the specified changes
lu.copy_constr <- function(constr, func) {
  expr <- func(constr$expr)
  new(class(constr), expr, constr$constr_id, constr$dim)
}

#' Replace the given variables in the expression
#' @param expr the `LinOp` expression to replace variables in
#' @param id_to_new_var a map of id to new variable
#' @return an LinOp identical to expr, but with the given variables replaced
#' @export
lu.replace_new_vars <- function(expr, id_to_new_var) {
  if(expr$type == lo.VARIABLE && expr$data %in% id_to_new_var)
    id_to_new_var[expr$data]
  else {
    new_args <- list()
    for(arg in expr$args)
      new_args <- c(new_args, replace_new_vars(arg, id_to_new_var))
    lo.LinOp(expr$type, expr$dim, new_args, expr$data)
  }
}

#' Replace parameters with constant nodes
#' @param expr the `LinOp` expression to replace parameters in
#' @return an LinOp identical to expr, but with the parameters replaced
lu.replace_params_with_consts <- function(expr) {
  if(expr$type == lo.PARAM)
    lu.create_const(expr$data$value, expr$dim)
  else {
    new_args <- list()
    for(arg in expr$args)
      new_args <- c(new_args, replace_params_with_consts(arg))
    # Data could also be a parameter
    if(inherits(expr$data, "LinOp") && expr$data$type == lo.PARAM) {
      data_lin_op <- expr$data
      data <- lu.create_const(data_lin_op$data$value, data_lin_op$dim)
    } else
      data <- expr$data
    lo.LinOp(expr$type, expr$dim, new_args, data)
  }
}
