#####
## DO NOT EDIT THIS FILE!! EDIT THE SOURCE INSTEAD: rsrc_tree/atoms/atom.R
#####

## CVXPY SOURCE: cvxpy/atoms/atom.py

#'
#' The Atom class.
#'
#' This virtual class represents atomic expressions in CVXR.
#'
#' @name Atom-class
#' @aliases Atom
#' @rdname Atom-class
Atom <- setClass("Atom", representation(atom_args = "list", .dim = "NumORNULL"),
                 prototype(atom_args = list(), .dim = NULL), contains = c("VIRTUAL", "Expression"))

setMethod("initialize", "Atom", function(.Object, ..., atom_args = list(), .dim = NULL, validate = TRUE) {
  # .Object@id <- ifelse(is.na(id), get_id(), id)
  .Object <- callNextMethod(.Object, ..., validate = FALSE)

  if(length(atom_args) == 0)
    stop("No arguments given to ", class(.Object), ".")
  .Object@args <- lapply(atom_args, as.Constant)
  validate_args(.Object)

  .Object@.dim <- dim_from_args(.Object)
  if(length(.Object@.dim) > 2)
    stop("Atoms must be at most 2D.")
  if(validate)
    validObject(.Object)
  .Object
})

#'
#' Variable, Parameter, or Expression Name
#'
#' The string representation of a variable, parameter, or expression.
#'
#' @param x A \linkS4class{Variable}, \linkS4class{Parameter}, or \linkS4class{Expression} object.
#' @return For \linkS4class{Variable} or \linkS4class{Parameter} objects, the value in the name slot. For \linkS4class{Expression} objects, a string indicating the nested atoms and their respective arguments.
#' @docType methods
#' @rdname name
#' @examples
#' x <- Variable()
#' y <- Variable(3, name = "yVar")
#'
#' name(x)
#' name(y)
setMethod("name", "Atom", function(x) {
  data <- sapply(get_data(x), as.character)
  arg_names <- sapply(x@args, name)
  paste0(class(x), "(", paste(c(arg_names, data), collapse = ", "), ")")
})

setMethod("show", "Atom", function(object) {
  cli::cli_text(name(object))
})

#'
#' Validate Arguments
#'
#' Validate an atom's arguments, returning an error if any are invalid.
#'
#' @param object an \linkS4class{Atom} object
#' @docType methods
#' @rdname validate_args
setMethod("validate_args", "Atom", function(object) {
  if(!allow_complex(object) && any(sapply(object@args, is_complex)))
    stop("Arguments to ", class(object), " cannot be complex.")
})

#'
#' Atom Dimensions
#'
#' Determine the dimensions of an atom based on its arguments.
#'
#' @param object An \linkS4class{Atom} object.
#' @return A numeric vector \code{c(row, col)} indicating the dimensions of the atom.
#' @rdname dim_from_args
setMethod("dim_from_args", "Atom", function(object) { stop("Unimplemented") })

## TODO: Why isn't dim a generic?
#' @describeIn Atom The \code{c(row, col)} dimensions of the atom.
setMethod("dim", "Atom", function(x) { x@.dim })

## TODO: Why isn't nrow a generic?
#' @describeIn Atom The number of rows in the atom.
setMethod("nrow", "Atom", function(x) { dim(x)[1] })

## TODO: Why isn't ncol a generic?
#' @describeIn Atom The number of columns in the atom.
setMethod("ncol", "Atom", function(x) { dim(x)[2] })

#' Does the atom handle complex numbers?
#' @param object an \linkS4class{Atom} object
setMethod("allow_complex", "Atom", function(object) { FALSE })

#'
#' Atom Sign
#'
#' Determine the sign of an atom based on its arguments.
#'
#' @param object An \linkS4class{Atom} object.
#' @return A logical vector \code{c(is positive, is negative)} indicating the sign of the atom.
#' @rdname sign_from_args
setMethod("sign_from_args", "Atom", function(object) { stop("Unimplemented") })

#' Is an atom non_negative?
#' @param object an atom
#' @return a logical value indicating whether the atom is nonnegative
setMethod("is_nonneg", "Atom", function(object) { sign_from_args(object)[1] })

#' Is an atom non_positive?
#' @param object an atom
#' @return a logical value indicating whether the atom is nonnegative
#' @describeIn Atom A logical value indicating whether the atom is nonpositive.
setMethod("is_nonpos", "Atom", function(object) { sign_from_args(object)[2] })

## #' Is an atom real-valued?
## #' @param object an atom
## #' @return a logical value indicating whether the atom is real-valued

#' Is an atom imaginary?
#' @param object an atom
#' @return a logical value indicating whether the atom is imaginary
setMethod("is_imag", "Atom", function(object) { FALSE })

#' Is an atom complex-valued?
#' @param object an atom
#' @return a logical value indicating whether the atom is complex-valud
#' @describeIn Atom A logical value indicating whether the atom is complex valued.
setMethod("is_complex", "Atom", function(object) { FALSE })

#' @rdname curvature-atom
setMethod("is_atom_convex", "Atom", function(object) { stop("Unimplemented") })

#' @rdname curvature-atom
setMethod("is_atom_concave", "Atom", function(object) { stop("Unimplemented") })

#' @rdname curvature-atom
setMethod("is_atom_affine", "Atom", function(object) { is_atom_concave(object) && is_atom_convex(object) })

#' @rdname curvature-atom
setMethod("is_atom_log_log_convex", "Atom", function(object) { FALSE })

#' @rdname curvature-atom
setMethod("is_atom_log_log_concave", "Atom", function(object) { FALSE })

#' @rdname curvature-atom
setMethod("is_atom_log_log_affine", "Atom", function(object) { is_atom_log_log_concave(object) && is_atom_log_log_convex(object) })

#' @rdname curvature-atom
setMethod("is_atom_quasiconvex", "Atom", function(object) { is_atom_convex(object) })

#' @rdname curvature-atom
setMethod("is_atom_quasiconcave", "Atom", function(object) { is_atom_concave(object) })

#' @rdname curvature-comp
setMethod("is_incr", "Atom", function(object, idx) { stop("Unimplemented") })

#' @rdname curvature-comp
setMethod("is_decr", "Atom", function(object, idx) { stop("Unimplemented") })

#' @describeIn Atom A logical value indicating whether the atom is convex.
setMethod("is_convex", "Atom", function(object) {
  # Applies DCP composition rule
  if(is_constant(object))
    return(TRUE)
  else if(is_atom_convex(object)) {
    idx <- 1
    for(arg in object@args) {
      if(!(is_affine(arg) || (is_convex(arg) && is_incr(object, idx)) || (is_concave(arg) && is_decr(object, idx))))
        return(FALSE)
      idx <- idx + 1
    }
    return(TRUE)
  } else
    return(FALSE)
})

#' @describeIn Atom A logical value indicating whether the atom is concave.
setMethod("is_concave", "Atom", function(object) {
  # Applies DCP composition rule
  if(is_constant(object))
    return(TRUE)
  else if(is_atom_concave(object)) {
    idx <- 1
    for(arg in object@args) {
      if(!(is_affine(arg) || (is_concave(arg) && is_incr(object, idx)) || (is_convex(arg) && is_decr(object, idx))))
        return(FALSE)
      idx <- idx + 1
    }
    return(TRUE)
  } else
    return(FALSE)
})

#' @describeIn Atom A logical value indicating whether the atom is a disciplined parameterized expression.
setMethod("is_dpp", "Atom", function(object, context = c("dcp", "dgp")) {
  context <- match.arg(context)
  if(tolower(context) == "dcp")
    return(is_dcp(object, dpp = TRUE))
  else 
    return(is_dgp(object, dpp = TRUE))
})

#' @describeIn Atom A logical value indicating whether the atom is log-log convex.
setMethod("is_log_log_convex", "Atom", function(object) {
  # Verifies DGP composition rule.
  if(is_log_log_constant(object))
    return(TRUE)
  else if(is_atom_log_log_convex(object)) {
    idx <- 1
    for(arg in object@args) {
      if(!(is_log_log_affine(arg) || (is_log_log_convex(arg) && is_incr(object, idx)) || (is_log_log_concave(arg) && is_decr(object, idx))))
        return(FALSE)
      idx <- idx + 1
    }
    return(TRUE)
  } else
    return(FALSE)
})

#' @describeIn Atom A logical value indicating whether the atom is log-log concave.
setMethod("is_log_log_concave", "Atom", function(object) {
  # Verifies DGP composition rule.
  if(is_log_log_constant(object))
    return(TRUE)
  else if(is_atom_log_log_concave(object)) {
    idx <- 1
    for(arg in object@args) {
      if(!(is_log_log_affine(arg) || (is_log_log_concave(arg) && is_incr(object, idx)) || (is_log_log_convex(arg) && is_decr(object, idx))))
        return(FALSE)
      idx <- idx + 1
    }
    return(TRUE)
  } else
    return(FALSE)
})

## Begin Naras Fix.
## These are internal and so should not be methods. The first is also missing a negation.
## setMethod(".non_const_idx", "Atom", function(object) {
##   return(which(sapply(object@args, is_constant)))
## })
## setMethod(".is_real", "Atom", function(object) {
##   # Returns TRUE if this atom is a real function:
##   #    The atom must have exactly one argument that is not a constant.
##   #    The argument must be a scalar.
##   #    The output must be a scalar.
##   non_const <- .non_const_idx(object)
##   return(is_scalar(object) && len(non_const) == 1 && is_scalar(object@args[[non_const[1]]]))
## })
## End Naras Fix.

.non_const_idx_of_args_in_atom <- function(object) {
  which(! unlist(apply(object@args, is_constant)) )
}

.is_atom_real <- function(object) {
  # Returns TRUE if this atom is a real function:
  #    The atom must have exactly one argument that is not a constant.
  #    The argument must be a scalar.
  #    The output must be a scalar.
  non_const <- .non_const_idx_of_args_in_atom(object)
  return(is_scalar(object) && len(non_const) == 1L && is_scalar(object@args[[non_const[1L]]]))
}

#' @describeIn Atom A logical value indicating whether the atom is quasiconvex.
setMethod("is_quasiconvex", "Atom", function(object) {
  if(is_convex(object))
    return(TRUE)
  if(class(object) == "MaxElemwise" || class(object) == "MaxEntries")
    return(all(sapply(object@args, is_quasiconvex)))
  non_const <- .non_const_idx_of_args_in_atom(object)
  if(.is_atom_real(object) && is_incr(object, non_const[[1]]))
    return(is_quasiconvex(object@args[[non_const[[1]]]]))
  if(.is_atom_real(object) && is_decr(object, non_const[[1]]))
    return(is_quasiconcave(object@args[[non_const[[1]]]]))
  if(is_atom_quasiconvex(object)) {
    idx <- 1
	for(arg in object@args) {
	  if(!(is_affine(arg) || (is_convex(arg) && is_incr(object, idx)) || (is_concave(arg) && is_decr(object, idx))))
	    return(FALSE)
	  idx <- idx + 1
    }
	return(TRUE)
  }
  return(FALSE)
})

#' @describeIn Atom A logical value indicating whether the atom is quasiconcave.
setMethod("is_quasiconcave", "Atom", function(object) {
  if(is_concave(object))
    return(TRUE)
  if(class(object) == "MinElemwise" || class(object) == "MinEntries")
    return(all(sapply(object@args, is_quasiconcave)))
  non_const <- .non_const_idx_of_args_in_atom(object)
  if(.is_atom_real(object) && is_incr(object, non_const[[1]]))
    return(is_quasiconcave(object@args[[non_const[[1]]]]))
  if(.is_atom_real(object) && is_decr(object, non_const[[1]]))
    return(is_quasiconvex(object@args[[non_const[[1]]]]))
  if(is_atom_quasiconcave(object)) {
    idx <- 1
	for(arg in object@args) {
	  if(!(is_affine(arg) || (is_concave(arg) && is_incr(object, idx)) || (is_convex(arg) && is_decr(object, idx))))
	    return(FALSE)
	  idx <- idx + 1
    }
	return(TRUE)
  }
  return(FALSE)
})

#' @describeIn Atom Represent the atom as an affine objective and conic constraints.
setMethod("canonicalize", "Atom", function(object) {
  # Constant atoms are treated as a leaf.
  if(is_constant(object) && !is.na(parameters(object)) && length(parameters(object)) > 0)
      # Non-parameterized expressions are evaluated immediately.
      return(canonical_form(Constant(value(object))))
  else {
    arg_objs <- list()
    constraints <- list()
    for(arg in object@args) {
      canon <- canonical_form(arg)
      arg_objs[[length(arg_objs) + 1]] <- canon[[1]]
      constraints <- c(constraints, canon[[2]])
    }
    # Special info required by the graph implementation.
    data <- get_data(object)
    graph <- graph_implementation(object, arg_objs, dim(object), data)
    return(list(graph[[1]], c(constraints, graph[[2]])))
  }
})

#' @param arg_objs A list of linear expressions for each argument.
#' @param dim A vector with two elements representing the dimensions of the resulting expression.
#' @param data A list of additional data required by the atom.
#' @describeIn Atom The graph implementation of the atom.
setMethod("graph_implementation", "Atom", function(object, arg_objs, dim, data = NA_real_) { stop("Unimplemented") })

# .value_impl.Atom <- function(object) {
#' @describeIn Atom Returns the value of each of the components in an Atom. Returns an empty matrix if it's an empty atom
setMethod("value_impl", "Atom", function(object) {
  obj_dim <- dim(object)
  # dims with 0's dropped in presolve.
  if(0 %in% obj_dim)
    result <- matrix(nrow = 0, ncol = 0)
  else {
    arg_values <- list()
    for(arg in object@args) {
      # An argument without a value makes all higher level values NA.
      # But if the atom is constant with non-constant arguments, it doesn't depend on its arguments, so it isn't NA.
      arg_val <- value_impl(arg)
      if(any(is.na(arg_val)) && !is_constant(object))
        return(NA_real_)
      else
        arg_values <- c(arg_values, list(arg_val))
    }
    result <- to_numeric(object, arg_values)
  }
  return(result)
})

#' @describeIn Atom Returns the value of the atom.
setMethod("value", "Atom", function(object) {
  if(any(sapply(parameters(object), function(p) { is.na(value(p)) })))
    return(NA_real_)
  return(value_impl(object))
})

#' @describeIn Atom The (sub/super)-gradient of the atom with respect to each variable.
setMethod("grad", "Atom", function(object) {
  # Short-circuit to all zeros if known to be constant
  if(is_constant(object))
    return(constant_grad(object))

  # Returns NA if variable values are not supplied
  arg_values <- list()
  for(arg in object@args) {
    arg_val <- value(arg)
    if(any(is.na(arg_val)))
      return(error_grad(object))
    else
      arg_values <- c(arg_values, list(arg_val))
  }

  # A list of gradients wrt arguments
  grad_self <- .grad(object, arg_values)

  # The chain rule
  result <- list()
  idx <- 1
  for(arg in object@args) {
    # A dictionary of gradients wrt variables.
    # Partial argument / partial x.
    grad_arg <- grad(arg)
    for(key in names(grad_arg)) {
      # None indicates gradient is not defined.
      if(any(is.na( as.vector(grad_arg[[key]]) )) || any(is.na( as.vector(grad_self[[idx]]) )))
        result[[key]] <- NA_real_
      else {
        D <- grad_arg[[key]] %*% grad_self[[idx]]
        # Convert 1x1 matrices to scalars.
        if((is.matrix(D) || is(D, "Matrix")) && all(dim(D) == c(1,1)))
          D <- D[1,1]

        if(key %in% names(result))
          result[[key]] <- result[[key]] + D
        else
          result[[key]] <- D
      }
    }
    idx <- idx + 1
  }
  return(result)
})

setMethod(".grad", "Atom", function(object, values) { stop("Unimplemented") })

#' @describeIn Atom A list of constraints describing the closure of the region where the expression is finite.
setMethod("domain", "Atom", function(object) {
  cons <- list()
  for(arg in object@args) {
    for(con in domain(arg))
      cons <- c(cons, con)
  }
  c(.domain(object), cons)
})

setMethod(".domain", "Atom", function(object) { list() })

#' @describeIn Atom Returns a list of the atom types present amongst this atom's arguments
setMethod("atoms", "Atom", function(object) {
  atom_list <- list()
  for(arg in object@args)
    atom_list <- c(atom_list, atoms(arg))
  atom_list <- c(atom_list, list(class(object)))
  return(unique(atom_list))
})
