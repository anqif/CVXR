#####
## DO NOT EDIT THIS FILE!! EDIT THE SOURCE INSTEAD: rsrc_tree/reductions/solvers/kktsolver.R
#####

## CVXPY SOURCE: cvxpy/reductions/solvers/kktsolver.py
################################################
#                 KKT SOLVER
################################################
# A custom KKT solver for CVXOPT that can handle redundant constraints.
# Uses regularization and iterative refinement.

REG_EPS <- 1e-9   # Regularization constant.

setup_ldl_factor <- function(c, G, h, dims, A, b) {
  # The meanings of arguments in this function are identical to those of the
  # function cvxopt.solvers.conelp. Refer to CVXOPT documentation
  #
  # https://cvxopt.org/userguide/coneprog.html#linear-cone-programs
  #
  # for more information.
  #
  # Note: CVXOPT allows G and A to be passed as dense matrix objects. However,
  # this function will only ever be called with spmatrix objects. If creating
  # a custom kktsolver of your own, you need to conform to this sparse matrix
  # assumption.

  factor <- kkt_ldl(G, dims, A)
  return(factor)
}

kkt_ldl <- function(G, dims, A) {
  # Returns a function handle "factor", which conforms to the CVXOPT
  # custom KKT solver specifications:
  #
  #     https://cvxopt.org/userguide/coneprog.html#exploiting-structure.
  #
  # For convenience, we provide a short outline for how this function works.
  #
  # First, we allocate workspace for use in "factor". The factor function is
  # called with data (H, W). Once called, the factor function computes an LDL
  # factorization of the 3 x 3 system:
  #
  #     [ H           A'   G'*W^{-1}  ]
  #     [ A           0    0          ].
  #     [ W^{-T}*G    0   -I          ]
  #
  # Once that LDL factorization is computed, "factor" constructs another
  # inner function, called "solve". The solve function uses the newly
  # constructed LDL factorization to compute solutions to linear systems of
  # the form
  #
  #     [ H     A'   G'    ]   [ ux ]   [ bx ]
  #     [ A     0    0     ] * [ uy ] = [ by ].
  #     [ G     0   -W'*W  ]   [ uz ]   [ bz ]
  #
  # The factor function concludes by returning a reference to the solve function.
  #
  # Note: In the 3 x 3 system, H is n x n, A is p x n, and G is N x n, where
  # N = dims[['l']] + sum(dims[['q']]) + sum(sapply(dims[['s']], function(k) { k^2 })).
  # For cone programs, H is the zero matrix.

  p <- nrow(A)
  n <- ncol(A)
  ldK <- n + p + dims$l + sum(dims$q) + sum(sapply(dims$s, function(k) { as.integer(k*(k+1)/2) } ))

  stop("CVXOPT KKT solver is unimplemented. Need to write most of the code in C++.")

  # TODO: These should all be CVXOPT matrix objects.
  K <- matrix(0, nrow = ldK, ncol = ldK)
  ipiv <- matrix(0, nrow = ldK, ncol = 1)
  u <- matrix(0, nrow = ldK, ncol = 1)
  g <- matrix(0, nrow = nrow(G), ncol = 1)

  factor <- function(W, H = NA_real_) {
    K <- 0*K
    if(!is.na(H))
      K[1:n, 1:n] <- H
    K[(n+1):(n+p+1), 1:n] <- A

    for(k in seq(n)) {
      g <- G[,k]
      # TODO: These should be calls to functions in CVXOPT (cvxopt.misc).
      # scale(g, W, trans='T', inverse='I')
      # pack(g, K, dims, 0, offsety=k*ldK + n + p)
    }
    K[seq((ldK+1)*(p+n) + 1, nrow(K), by = ldK+1)] <- -1.0

    # Add positive regularization in 1x1 block and negative in 2x2 block.
    K[seq(1, (ldK+1)*n, by = ldK+1)] <- K[seq(1, (ldK+1)*n, by = ldK+1)] + REG_EPS
    K[seq((ldK+1)*n + 1, nrow(K), by = ldK+1)] <- K[seq((ldK+1)*n + 1, nrow(K), by = ldK+1)] - REG_EPS
    # TODO: lapack.sytrf(K, ipiv)

    solve <- function(x, y, z) {
      # Solve
      #
      #     [ H          A'   G'*W^{-1}  ]   [ ux   ]   [ bx        ]
      #     [ A          0    0          ] * [ uy   [ = [ by        ]
      #     [ W^{-T}*G   0   -I          ]   [ W*uz ]   [ W^{-T}*bz ]
      #
      # and return ux, uy, W*uz.
      #
      # On entry, x, y, z contain bx, by, bz.  On exit, they contain
      # the solution ux, uy, W*uz.

      # TODO: This function needs to be implemented using CVXOPT/BLAS/LAPACK functions.
      # blas.copy(x, u)
      # blas.copy(y, u, offsety=n)
      # scale(z, W, trans='T', inverse='I')
      # pack(z, u, dims, 0, offsety=n + p)
      # lapack.sytrs(K, ipiv, u)
      # blas.copy(u, x, n=n)
      # blas.copy(u, y, offsetx=n, n=p)
      # unpack(u, z, dims, 0, offsetx=n + p)
    }

    return(solve)
  }

  return(factor)
}

