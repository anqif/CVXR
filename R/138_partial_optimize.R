#####
## DO NOT EDIT THIS FILE!! EDIT THE SOURCE INSTEAD: rsrc_tree/transforms/partial_optimize.R
#####

## CVXPY SOURCE: cvxpy/transforms/partial_optimize.py

####################
#                  #
# Partial Optimize #
#                  #
####################

#'
#' Partially optimizes the given problem over the specified variables.
#'
#'    Either opt_vars or dont_opt_vars must be given.
#'    If both are given, they must contain all the variables in the problem.
#'
#'    Partial optimize is useful for two-stage optimization and graph implementations.
#'    For example, we can write
#'
#'        x <- Variable(n)
#'        t <- Variable(n)
#'        abs_x <- partial_optimize(Problem(Minimize(sum(t)),
#'                                  list(-t <= x, x <= t)), opt_vars = list(t))
#'
#'    to define the entrywise absolute value of x.
#'
#' @param prob The problem to partially optimize.
#' @param opt_vars The variables to optimize over.
#' @param dont_opt_vars The variables to not optimize over.
#' @param solver The default solver to use for value and grad.
#' @param ... Additional solver specific keyword arguments.
#' @return An expression representing the partial optimization.
#'         Convex for minimization objectives and concave for maximization objectives.
#'
partial_optimize <- function(prob, opt_vars = list(), dont_opt_vars = list(), solver = NA, ...) {
  # One of the two arguments must be specified.
  if((is.null(opt_vars) || length(opt_vars) == 0) && (is.null(dont_opt_vars) || length(dont_opt_vars) == 0))
    stop("partial_optimize called with neither opt_vars nor dont_opt_vars")
  # If opt_vars is not specified, it's the complement of dont_opt_vars.
  else if(is.null(opt_vars) || length(opt_vars) == 0) {
    ids <- sapply(dont_opt_vars, id)
    opt_vars <- lapply(variables(prob), function(var) { if(!(id(var) %in% ids)) var })
  # If dont_opt_vars is not specified, it's the complement of opt_vars.
  } else if(is.null(dont_opt_vars) || length(dont_opt_vars) == 0) {
    ids <- sapply(opt_vars, id)
    dont_opt_vars <- lapply(variables(prob), function(var) { if(!(id(var) %in% ids)) var })
  } else if(!is.null(opt_vars) && length(opt_vars) != 0 && !is.null(dont_opt_vars) && length(dont_opt_vars) != 0) {
    ids <- sapply(c(opt_vars, dont_opt_vars), id)
    for(var in variables(prob)) {
      if(!(id(var) %in% ids))
        stop("If opt_vars and dont_opt_vars are both specified, they must contain all variables in the problem.")
    }
  }

  # Replace the opt_vars in prob with new variables.
  id_to_new_var <- list()
  for(var in opt_vars)
    id_to_new_var[[as.character(id(var))]] <- do.call(".Variable", c(list(dim = dim(var)), var@attributes))
  new_obj <- tree_copy(prob@objective, id_to_new_var)
  new_constrs <- lapply(prob@constraints, function(con) { tree_copy(con, id_to_new_var) })
  new_var_prob <- Problem(new_obj, new_constrs)
  PartialProblem(new_var_prob, opt_vars, dont_opt_vars, solver, ...)
}

